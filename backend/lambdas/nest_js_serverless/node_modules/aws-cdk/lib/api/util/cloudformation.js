"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParameterValues = exports.TemplateParameters = exports.stabilizeStack = exports.waitForStackDeploy = exports.waitForStackDelete = exports.changeSetHasNoChanges = exports.cleanupOldChangeset = exports.createDiffChangeSet = exports.waitForChangeSet = exports.CloudFormationStack = void 0;
const cx_api_1 = require("@aws-cdk/cx-api");
const stack_status_1 = require("./cloudformation/stack-status");
const template_body_parameter_1 = require("./template-body-parameter");
const logging_1 = require("../../logging");
const serialize_1 = require("../../serialize");
/**
 * Represents an (existing) Stack in CloudFormation
 *
 * Bundle and cache some information that we need during deployment (so we don't have to make
 * repeated calls to CloudFormation).
 */
class CloudFormationStack {
    static async lookup(cfn, stackName, retrieveProcessedTemplate = false) {
        try {
            const response = await cfn.describeStacks({ StackName: stackName }).promise();
            return new CloudFormationStack(cfn, stackName, response.Stacks && response.Stacks[0], retrieveProcessedTemplate);
        }
        catch (e) {
            if (e.code === 'ValidationError' && e.message === `Stack with id ${stackName} does not exist`) {
                return new CloudFormationStack(cfn, stackName, undefined);
            }
            throw e;
        }
    }
    /**
     * Return a copy of the given stack that does not exist
     *
     * It's a little silly that it needs arguments to do that, but there we go.
     */
    static doesNotExist(cfn, stackName) {
        return new CloudFormationStack(cfn, stackName);
    }
    /**
     * From static information (for testing)
     */
    static fromStaticInformation(cfn, stackName, stack) {
        return new CloudFormationStack(cfn, stackName, stack);
    }
    constructor(cfn, stackName, stack, retrieveProcessedTemplate = false) {
        this.cfn = cfn;
        this.stackName = stackName;
        this.stack = stack;
        this.retrieveProcessedTemplate = retrieveProcessedTemplate;
    }
    /**
     * Retrieve the stack's deployed template
     *
     * Cached, so will only be retrieved once. Will return an empty
     * structure if the stack does not exist.
     */
    async template() {
        if (!this.exists) {
            return {};
        }
        if (this._template === undefined) {
            const response = await this.cfn.getTemplate({
                StackName: this.stackName,
                TemplateStage: this.retrieveProcessedTemplate ? 'Processed' : 'Original',
            }).promise();
            this._template = (response.TemplateBody && (0, serialize_1.deserializeStructure)(response.TemplateBody)) || {};
        }
        return this._template;
    }
    /**
     * Whether the stack exists
     */
    get exists() {
        return this.stack !== undefined;
    }
    /**
     * The stack's ID
     *
     * Throws if the stack doesn't exist.
     */
    get stackId() {
        this.assertExists();
        return this.stack.StackId;
    }
    /**
     * The stack's current outputs
     *
     * Empty object if the stack doesn't exist
     */
    get outputs() {
        if (!this.exists) {
            return {};
        }
        const result = {};
        (this.stack.Outputs || []).forEach(output => {
            result[output.OutputKey] = output.OutputValue;
        });
        return result;
    }
    /**
     * The stack's status
     *
     * Special status NOT_FOUND if the stack does not exist.
     */
    get stackStatus() {
        if (!this.exists) {
            return new stack_status_1.StackStatus('NOT_FOUND', 'Stack not found during lookup');
        }
        return stack_status_1.StackStatus.fromStackDescription(this.stack);
    }
    /**
     * The stack's current tags
     *
     * Empty list of the stack does not exist
     */
    get tags() {
        return this.stack?.Tags || [];
    }
    /**
     * Return the names of all current parameters to the stack
     *
     * Empty list if the stack does not exist.
     */
    get parameterNames() {
        return Object.keys(this.parameters);
    }
    /**
     * Return the names and values of all current parameters to the stack
     *
     * Empty object if the stack does not exist.
     */
    get parameters() {
        if (!this.exists) {
            return {};
        }
        const ret = {};
        for (const param of this.stack.Parameters ?? []) {
            ret[param.ParameterKey] = param.ResolvedValue ?? param.ParameterValue;
        }
        return ret;
    }
    /**
     * Return the termination protection of the stack
     */
    get terminationProtection() {
        return this.stack?.EnableTerminationProtection;
    }
    assertExists() {
        if (!this.exists) {
            throw new Error(`No stack named '${this.stackName}'`);
        }
    }
}
exports.CloudFormationStack = CloudFormationStack;
/**
 * Describe a changeset in CloudFormation, regardless of its current state.
 *
 * @param cfn           a CloudFormation client
 * @param stackName     the name of the Stack the ChangeSet belongs to
 * @param changeSetName the name of the ChangeSet
 * @param fetchAll      if true, fetches all pages of the change set description.
 *
 * @returns       CloudFormation information about the ChangeSet
 */
async function describeChangeSet(cfn, stackName, changeSetName, { fetchAll }) {
    const response = await cfn.describeChangeSet({ StackName: stackName, ChangeSetName: changeSetName }).promise();
    // If fetchAll is true, traverse all pages from the change set description.
    while (fetchAll && response.NextToken != null) {
        const nextPage = await cfn.describeChangeSet({
            StackName: stackName,
            ChangeSetName: response.ChangeSetId ?? changeSetName,
            NextToken: response.NextToken,
        }).promise();
        // Consolidate the changes
        if (nextPage.Changes != null) {
            response.Changes = response.Changes != null
                ? response.Changes.concat(nextPage.Changes)
                : nextPage.Changes;
        }
        // Forward the new NextToken
        response.NextToken = nextPage.NextToken;
    }
    return response;
}
/**
 * Waits for a function to return non-+undefined+ before returning.
 *
 * @param valueProvider a function that will return a value that is not +undefined+ once the wait should be over
 * @param timeout     the time to wait between two calls to +valueProvider+
 *
 * @returns       the value that was returned by +valueProvider+
 */
async function waitFor(valueProvider, timeout = 5000) {
    while (true) {
        const result = await valueProvider();
        if (result === null) {
            return undefined;
        }
        else if (result !== undefined) {
            return result;
        }
        await new Promise(cb => setTimeout(cb, timeout));
    }
}
/**
 * Waits for a ChangeSet to be available for triggering a StackUpdate.
 *
 * Will return a changeset that is either ready to be executed or has no changes.
 * Will throw in other cases.
 *
 * @param cfn           a CloudFormation client
 * @param stackName     the name of the Stack that the ChangeSet belongs to
 * @param changeSetName the name of the ChangeSet
 * @param fetchAll      if true, fetches all pages of the ChangeSet before returning.
 *
 * @returns       the CloudFormation description of the ChangeSet
 */
// eslint-disable-next-line max-len
async function waitForChangeSet(cfn, stackName, changeSetName, { fetchAll }) {
    (0, logging_1.debug)('Waiting for changeset %s on stack %s to finish creating...', changeSetName, stackName);
    const ret = await waitFor(async () => {
        const description = await describeChangeSet(cfn, stackName, changeSetName, { fetchAll });
        // The following doesn't use a switch because tsc will not allow fall-through, UNLESS it is allows
        // EVERYWHERE that uses this library directly or indirectly, which is undesirable.
        if (description.Status === 'CREATE_PENDING' || description.Status === 'CREATE_IN_PROGRESS') {
            (0, logging_1.debug)('Changeset %s on stack %s is still creating', changeSetName, stackName);
            return undefined;
        }
        if (description.Status === 'CREATE_COMPLETE' || changeSetHasNoChanges(description)) {
            return description;
        }
        // eslint-disable-next-line max-len
        throw new Error(`Failed to create ChangeSet ${changeSetName} on ${stackName}: ${description.Status || 'NO_STATUS'}, ${description.StatusReason || 'no reason provided'}`);
    });
    if (!ret) {
        throw new Error('Change set took too long to be created; aborting');
    }
    return ret;
}
exports.waitForChangeSet = waitForChangeSet;
/**
 * Create a changeset for a diff operation
 */
async function createDiffChangeSet(options) {
    // `options.stack` has been modified to include any nested stack templates directly inline with its own template, under a special `NestedTemplate` property.
    // Thus the parent template's Resources section contains the nested template's CDK metadata check, which uses Fn::Equals.
    // This causes CreateChangeSet to fail with `Template Error: Fn::Equals cannot be partially collapsed`.
    for (const resource of Object.values((options.stack.template.Resources ?? {}))) {
        if (resource.Type === 'AWS::CloudFormation::Stack') {
            // eslint-disable-next-line no-console
            (0, logging_1.debug)('This stack contains one or more nested stacks, falling back to template-only diff...');
            return undefined;
        }
    }
    return uploadBodyParameterAndCreateChangeSet(options);
}
exports.createDiffChangeSet = createDiffChangeSet;
async function uploadBodyParameterAndCreateChangeSet(options) {
    try {
        const preparedSdk = (await options.deployments.prepareSdkWithDeployRole(options.stack));
        const bodyParameter = await (0, template_body_parameter_1.makeBodyParameterAndUpload)(options.stack, preparedSdk.resolvedEnvironment, preparedSdk.envResources, options.sdkProvider, preparedSdk.stackSdk);
        const cfn = preparedSdk.stackSdk.cloudFormation();
        const exists = (await CloudFormationStack.lookup(cfn, options.stack.stackName, false)).exists;
        const executionRoleArn = preparedSdk.cloudFormationRoleArn;
        options.stream.write('Hold on while we create a read-only change set to get a diff with accurate replacement information (use --no-change-set to use a less accurate but faster template-only diff)\n');
        return await createChangeSet({
            cfn,
            changeSetName: 'cdk-diff-change-set',
            stack: options.stack,
            exists,
            uuid: options.uuid,
            willExecute: options.willExecute,
            bodyParameter,
            parameters: options.parameters,
            resourcesToImport: options.resourcesToImport,
            role: executionRoleArn,
        });
    }
    catch (e) {
        (0, logging_1.debug)(e.message);
        options.stream.write('Could not create a change set, will base the diff on template differences (run again with -v to see the reason)\n');
        return undefined;
    }
}
async function createChangeSet(options) {
    await cleanupOldChangeset(options.changeSetName, options.stack.stackName, options.cfn);
    (0, logging_1.debug)(`Attempting to create ChangeSet with name ${options.changeSetName} for stack ${options.stack.stackName}`);
    const templateParams = TemplateParameters.fromTemplate(options.stack.template);
    const stackParams = templateParams.supplyAll(options.parameters);
    const changeSet = await options.cfn.createChangeSet({
        StackName: options.stack.stackName,
        ChangeSetName: options.changeSetName,
        ChangeSetType: options.resourcesToImport ? 'IMPORT' : options.exists ? 'UPDATE' : 'CREATE',
        Description: `CDK Changeset for diff ${options.uuid}`,
        ClientToken: `diff${options.uuid}`,
        TemplateURL: options.bodyParameter.TemplateURL,
        TemplateBody: options.bodyParameter.TemplateBody,
        Parameters: stackParams.apiParameters,
        ResourcesToImport: options.resourcesToImport,
        RoleARN: options.role,
        Capabilities: ['CAPABILITY_IAM', 'CAPABILITY_NAMED_IAM', 'CAPABILITY_AUTO_EXPAND'],
    }).promise();
    (0, logging_1.debug)('Initiated creation of changeset: %s; waiting for it to finish creating...', changeSet.Id);
    // Fetching all pages if we'll execute, so we can have the correct change count when monitoring.
    const createdChangeSet = await waitForChangeSet(options.cfn, options.stack.stackName, options.changeSetName, { fetchAll: options.willExecute });
    await cleanupOldChangeset(options.changeSetName, options.stack.stackName, options.cfn);
    // TODO: Update this once we remove sdkv2 from the rest of this package
    return createdChangeSet;
}
async function cleanupOldChangeset(changeSetName, stackName, cfn) {
    // Delete any existing change sets generated by CDK since change set names must be unique.
    // The delete request is successful as long as the stack exists (even if the change set does not exist).
    (0, logging_1.debug)(`Removing existing change set with name ${changeSetName} if it exists`);
    await cfn.deleteChangeSet({ StackName: stackName, ChangeSetName: changeSetName }).promise();
}
exports.cleanupOldChangeset = cleanupOldChangeset;
/**
 * Return true if the given change set has no changes
 *
 * This must be determined from the status, not the 'Changes' array on the
 * object; the latter can be empty because no resources were changed, but if
 * there are changes to Outputs, the change set can still be executed.
 */
function changeSetHasNoChanges(description) {
    const noChangeErrorPrefixes = [
        // Error message for a regular template
        'The submitted information didn\'t contain changes.',
        // Error message when a Transform is involved (see #10650)
        'No updates are to be performed.',
    ];
    return description.Status === 'FAILED'
        && noChangeErrorPrefixes.some(p => (description.StatusReason ?? '').startsWith(p));
}
exports.changeSetHasNoChanges = changeSetHasNoChanges;
/**
 * Waits for a CloudFormation stack to stabilize in a complete/available state
 * after a delete operation is issued.
 *
 * Fails if the stack is in a FAILED state. Will not fail if the stack was
 * already deleted.
 *
 * @param cfn        a CloudFormation client
 * @param stackName      the name of the stack to wait for after a delete
 *
 * @returns     the CloudFormation description of the stabilized stack after the delete attempt
 */
async function waitForStackDelete(cfn, stackName) {
    const stack = await stabilizeStack(cfn, stackName);
    if (!stack) {
        return undefined;
    }
    const status = stack.stackStatus;
    if (status.isFailure) {
        throw new Error(`The stack named ${stackName} is in a failed state. You may need to delete it from the AWS console : ${status}`);
    }
    else if (status.isDeleted) {
        return undefined;
    }
    return stack;
}
exports.waitForStackDelete = waitForStackDelete;
/**
 * Waits for a CloudFormation stack to stabilize in a complete/available state
 * after an update/create operation is issued.
 *
 * Fails if the stack is in a FAILED state, ROLLBACK state, or DELETED state.
 *
 * @param cfn        a CloudFormation client
 * @param stackName      the name of the stack to wait for after an update
 *
 * @returns     the CloudFormation description of the stabilized stack after the update attempt
 */
async function waitForStackDeploy(cfn, stackName) {
    const stack = await stabilizeStack(cfn, stackName);
    if (!stack) {
        return undefined;
    }
    const status = stack.stackStatus;
    if (status.isCreationFailure) {
        throw new Error(`The stack named ${stackName} failed creation, it may need to be manually deleted from the AWS console: ${status}`);
    }
    else if (!status.isDeploySuccess) {
        throw new Error(`The stack named ${stackName} failed to deploy: ${status}`);
    }
    return stack;
}
exports.waitForStackDeploy = waitForStackDeploy;
/**
 * Wait for a stack to become stable (no longer _IN_PROGRESS), returning it
 */
async function stabilizeStack(cfn, stackName) {
    (0, logging_1.debug)('Waiting for stack %s to finish creating or updating...', stackName);
    return waitFor(async () => {
        const stack = await CloudFormationStack.lookup(cfn, stackName);
        if (!stack.exists) {
            (0, logging_1.debug)('Stack %s does not exist', stackName);
            return null;
        }
        const status = stack.stackStatus;
        if (status.isInProgress) {
            (0, logging_1.debug)('Stack %s has an ongoing operation in progress and is not stable (%s)', stackName, status);
            return undefined;
        }
        else if (status.isReviewInProgress) {
            // This may happen if a stack creation operation is interrupted before the ChangeSet execution starts. Recovering
            // from this would requiring manual intervention (deleting or executing the pending ChangeSet), and failing to do
            // so will result in an endless wait here (the ChangeSet wont delete or execute itself). Instead of blocking
            // "forever" we proceed as if the stack was existing and stable. If there is a concurrent operation that just
            // hasn't finished proceeding just yet, either this operation or the concurrent one may fail due to the other one
            // having made progress. Which is fine. I guess.
            (0, logging_1.debug)('Stack %s is in REVIEW_IN_PROGRESS state. Considering this is a stable status (%s)', stackName, status);
        }
        return stack;
    });
}
exports.stabilizeStack = stabilizeStack;
/**
 * The set of (formal) parameters that have been declared in a template
 */
class TemplateParameters {
    static fromTemplate(template) {
        return new TemplateParameters(template.Parameters || {});
    }
    constructor(params) {
        this.params = params;
    }
    /**
     * Calculate stack parameters to pass from the given desired parameter values
     *
     * Will throw if parameters without a Default value or a Previous value are not
     * supplied.
     */
    supplyAll(updates) {
        return new ParameterValues(this.params, updates);
    }
    /**
     * From the template, the given desired values and the current values, calculate the changes to the stack parameters
     *
     * Will take into account parameters already set on the template (will emit
     * 'UsePreviousValue: true' for those unless the value is changed), and will
     * throw if parameters without a Default value or a Previous value are not
     * supplied.
     */
    updateExisting(updates, previousValues) {
        return new ParameterValues(this.params, updates, previousValues);
    }
}
exports.TemplateParameters = TemplateParameters;
/**
 * The set of parameters we're going to pass to a Stack
 */
class ParameterValues {
    constructor(formalParams, updates, previousValues = {}) {
        this.formalParams = formalParams;
        this.values = {};
        this.apiParameters = [];
        const missingRequired = new Array();
        for (const [key, formalParam] of Object.entries(this.formalParams)) {
            // Check updates first, then use the previous value (if available), then use
            // the default (if available).
            //
            // If we don't find a parameter value using any of these methods, then that's an error.
            const updatedValue = updates[key];
            if (updatedValue !== undefined) {
                this.values[key] = updatedValue;
                this.apiParameters.push({ ParameterKey: key, ParameterValue: updates[key] });
                continue;
            }
            if (key in previousValues) {
                this.values[key] = previousValues[key];
                this.apiParameters.push({ ParameterKey: key, UsePreviousValue: true });
                continue;
            }
            if (formalParam.Default !== undefined) {
                this.values[key] = formalParam.Default;
                continue;
            }
            // Oh no
            missingRequired.push(key);
        }
        if (missingRequired.length > 0) {
            throw new Error(`The following CloudFormation Parameters are missing a value: ${missingRequired.join(', ')}`);
        }
        // Just append all supplied overrides that aren't really expected (this
        // will fail CFN but maybe people made typos that they want to be notified
        // of)
        const unknownParam = ([key, _]) => this.formalParams[key] === undefined;
        const hasValue = ([_, value]) => !!value;
        for (const [key, value] of Object.entries(updates).filter(unknownParam).filter(hasValue)) {
            this.values[key] = value;
            this.apiParameters.push({ ParameterKey: key, ParameterValue: value });
        }
    }
    /**
     * Whether this set of parameter updates will change the actual stack values
     */
    hasChanges(currentValues) {
        // If any of the parameters are SSM parameters, deploying must always happen
        // because we can't predict what the values will be. We will allow some
        // parameters to opt out of this check by having a magic string in their description.
        if (Object.values(this.formalParams).some(p => p.Type.startsWith('AWS::SSM::Parameter::') && !p.Description?.includes(cx_api_1.SSMPARAM_NO_INVALIDATE))) {
            return 'ssm';
        }
        // Otherwise we're dirty if:
        // - any of the existing values are removed, or changed
        if (Object.entries(currentValues).some(([key, value]) => !(key in this.values) || value !== this.values[key])) {
            return true;
        }
        // - any of the values we're setting are new
        if (Object.keys(this.values).some(key => !(key in currentValues))) {
            return true;
        }
        return false;
    }
}
exports.ParameterValues = ParameterValues;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xvdWRmb3JtYXRpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjbG91ZGZvcm1hdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFFQSw0Q0FBeUQ7QUFHekQsZ0VBQTREO0FBQzVELHVFQUE4RjtBQUM5RiwyQ0FBc0M7QUFDdEMsK0NBQXVEO0FBb0J2RDs7Ozs7R0FLRztBQUNILE1BQWEsbUJBQW1CO0lBQ3ZCLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUN4QixHQUFtQixFQUFFLFNBQWlCLEVBQUUsNEJBQXFDLEtBQUs7UUFFbEYsSUFBSTtZQUNGLE1BQU0sUUFBUSxHQUFHLE1BQU0sR0FBRyxDQUFDLGNBQWMsQ0FBQyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQzlFLE9BQU8sSUFBSSxtQkFBbUIsQ0FBQyxHQUFHLEVBQUUsU0FBUyxFQUFFLFFBQVEsQ0FBQyxNQUFNLElBQUksUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSx5QkFBeUIsQ0FBQyxDQUFDO1NBQ2xIO1FBQUMsT0FBTyxDQUFNLEVBQUU7WUFDZixJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssaUJBQWlCLElBQUksQ0FBQyxDQUFDLE9BQU8sS0FBSyxpQkFBaUIsU0FBUyxpQkFBaUIsRUFBRTtnQkFDN0YsT0FBTyxJQUFJLG1CQUFtQixDQUFDLEdBQUcsRUFBRSxTQUFTLEVBQUUsU0FBUyxDQUFDLENBQUM7YUFDM0Q7WUFDRCxNQUFNLENBQUMsQ0FBQztTQUNUO0lBQ0gsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxNQUFNLENBQUMsWUFBWSxDQUFDLEdBQW1CLEVBQUUsU0FBaUI7UUFDL0QsT0FBTyxJQUFJLG1CQUFtQixDQUFDLEdBQUcsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUNqRCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxNQUFNLENBQUMscUJBQXFCLENBQUMsR0FBbUIsRUFBRSxTQUFpQixF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Q0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLGFBQWEsQ0FBQyxDQUFDLEVBQUU7WUFDakUsT0FBTyxJQUFJLENBQUM7U0FDYjtRQUVELE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztDQUNGO0FBN0VELDBDQTZFQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFRlbXBvcmFyaWx5IHB1bGwgdGhpcyBpbiB0byBhdm9pZCBjcmVhdGluZyBjb25mbGljdHMgd2l0aCB0aGUgc2RrcyBpbiB0aGlzIHBhY2thZ2VcbmltcG9ydCB7IERlc2NyaWJlQ2hhbmdlU2V0T3V0cHV0IH0gZnJvbSAnQGF3cy1jZGsvY2xvdWRmb3JtYXRpb24tZGlmZic7XG5pbXBvcnQgeyBTU01QQVJBTV9OT19JTlZBTElEQVRFIH0gZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgeyBDbG91ZEZvcm1hdGlvbiB9IGZyb20gJ2F3cy1zZGsnO1xuaW1wb3J0IHsgU3RhY2tTdGF0dXMgfSBmcm9tICcuL2Nsb3VkZm9ybWF0aW9uL3N0YWNrLXN0YXR1cyc7XG5pbXBvcnQgeyBtYWtlQm9keVBhcmFtZXRlckFuZFVwbG9hZCwgVGVtcGxhdGVCb2R5UGFyYW1ldGVyIH0gZnJvbSAnLi90ZW1wbGF0ZS1ib2R5LXBhcmFtZXRlcic7XG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4uLy4uL2xvZ2dpbmcnO1xuaW1wb3J0IHsgZGVzZXJpYWxpemVTdHJ1Y3R1cmUgfSBmcm9tICcuLi8uLi9zZXJpYWxpemUnO1xuaW1wb3J0IHsgU2RrUHJvdmlkZXIgfSBmcm9tICcuLi9hd3MtYXV0aCc7XG5pbXBvcnQgeyBEZXBsb3ltZW50cyB9IGZyb20gJy4uL2RlcGxveW1lbnRzJztcblxuZXhwb3J0IHR5cGUgVGVtcGxhdGUgPSB7XG4gIFBhcmFtZXRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBUZW1wbGF0ZVBhcmFtZXRlcj47XG4gIFtrZXk6IHN0cmluZ106IGFueTtcbn07XG5cbmludGVyZmFjZSBUZW1wbGF0ZVBhcmFtZXRlciB7XG4gIFR5cGU6IHN0cmluZztcbiAgRGVmYXVsdD86IGFueTtcbiAgRGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gIFtrZXk6IHN0cmluZ106IGFueTtcbn1cblxuZXhwb3J0IHR5cGUgUmVzb3VyY2VJZGVudGlmaWVyUHJvcGVydGllcyA9IENsb3VkRm9ybWF0aW9uLlJlc291cmNlSWRlbnRpZmllclByb3BlcnRpZXM7XG5leHBvcnQgdHlwZSBSZXNvdXJjZUlkZW50aWZpZXJTdW1tYXJpZXMgPSBDbG91ZEZvcm1hdGlvbi5SZXNvdXJjZUlkZW50aWZpZXJTdW1tYXJpZXM7XG5leHBvcnQgdHlwZSBSZXNvdXJjZXNUb0ltcG9ydCA9IENsb3VkRm9ybWF0aW9uLlJlc291cmNlc1RvSW1wb3J0O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gKGV4aXN0aW5nKSBTdGFjayBpbiBDbG91ZEZvcm1hdGlvblxuICpcbiAqIEJ1bmRsZSBhbmQgY2FjaGUgc29tZSBpbmZvcm1hdGlvbiB0aGF0IHdlIG5lZWQgZHVyaW5nIGRlcGxveW1lbnQgKHNvIHdlIGRvbid0IGhhdmUgdG8gbWFrZVxuICogcmVwZWF0ZWQgY2FsbHMgdG8gQ2xvdWRGb3JtYXRpb24pLlxuICovXG5leHBvcnQgY2xhc3MgQ2xvdWRGb3JtYXRpb25TdGFjayB7XG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgbG9va3VwKFxuICAgIGNmbjogQ2xvdWRGb3JtYXRpb24sIHN0YWNrTmFtZTogc3RyaW5nLCByZXRyaWV2ZVByb2Nlc3NlZFRlbXBsYXRlOiBib29sZWFuID0gZmFsc2UsXG4gICk6IFByb21pc2U8Q2xvdWRGb3JtYXRpb25TdGFjaz4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNmbi5kZXNjcmliZVN0YWNrcyh7IFN0YWNrTmFtZTogc3RhY2tOYW1lIH0pLnByb21pc2UoKTtcbiAgICAgIHJldHVybiBuZXcgQ2xvdWRGb3JtYXRpb25TdGFjayhjZm4sIHN0YWNrTmFtZSwgcmVzcG9uc2UuU3RhY2tzICYmIHJlc3BvbnNlLlN0YWNrc1swXSwgcmV0cmlldmVQcm9jZXNzZWRUZW1wbGF0ZSk7XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICBpZiAoZS5jb2RlID09PSAnVmFsaWRhdGlvbkVycm9yJyAmJiBlLm1lc3NhZ2UgPT09IGBTdGFjayB3aXRoIGlkICR7c3RhY2tOYW1lfSBkb2VzIG5vdCBleGlzdGApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDbG91ZEZvcm1hdGlvblN0YWNrKGNmbiwgc3RhY2tOYW1lLCB1bmRlZmluZWQpO1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgY29weSBvZiB0aGUgZ2l2ZW4gc3RhY2sgdGhhdCBkb2VzIG5vdCBleGlzdFxuICAgKlxuICAgKiBJdCdzIGEgbGl0dGxlIHNpbGx5IHRoYXQgaXQgbmVlZHMgYXJndW1lbnRzIHRvIGRvIHRoYXQsIGJ1dCB0aGVyZSB3ZSBnby5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZG9lc05vdEV4aXN0KGNmbjogQ2xvdWRGb3JtYXRpb24sIHN0YWNrTmFtZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBDbG91ZEZvcm1hdGlvblN0YWNrKGNmbiwgc3RhY2tOYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGcm9tIHN0YXRpYyBpbmZvcm1hdGlvbiAoZm9yIHRlc3RpbmcpXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21TdGF0aWNJbmZvcm1hdGlvbihjZm46IENsb3VkRm9ybWF0aW9uLCBzdGFja05hbWU6IHN0cmluZywgc3RhY2s6IENsb3VkRm9ybWF0aW9uLlN0YWNrKSB7XG4gICAgcmV0dXJuIG5ldyBDbG91ZEZvcm1hdGlvblN0YWNrKGNmbiwgc3RhY2tOYW1lLCBzdGFjayk7XG4gIH1cblxuICBwcml2YXRlIF90ZW1wbGF0ZTogYW55O1xuXG4gIHByb3RlY3RlZCBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNmbjogQ2xvdWRGb3JtYXRpb24sIHB1YmxpYyByZWFkb25seSBzdGFja05hbWU6IHN0cmluZywgcHJpdmF0ZSByZWFkb25seSBzdGFjaz86IENsb3VkRm9ybWF0aW9uLlN0YWNrLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcmV0cmlldmVQcm9jZXNzZWRUZW1wbGF0ZTogYm9vbGVhbiA9IGZhbHNlLFxuICApIHtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgc3RhY2sncyBkZXBsb3llZCB0ZW1wbGF0ZVxuICAgKlxuICAgKiBDYWNoZWQsIHNvIHdpbGwgb25seSBiZSByZXRyaWV2ZWQgb25jZS4gV2lsbCByZXR1cm4gYW4gZW1wdHlcbiAgICogc3RydWN0dXJlIGlmIHRoZSBzdGFjayBkb2VzIG5vdCBleGlzdC5cbiAgICovXG4gIHB1YmxpYyBhc3luYyB0ZW1wbGF0ZSgpOiBQcm9taXNlPFRlbXBsYXRlPiB7XG4gICAgaWYgKCF0aGlzLmV4aXN0cykge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLl90ZW1wbGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2ZuLmdldFRlbXBsYXRlKHtcbiAgICAgICAgU3RhY2tOYW1lOiB0aGlzLnN0YWNrTmFtZSxcbiAgICAgICAgVGVtcGxhdGVTdGFnZTogdGhpcy5yZXRyaWV2ZVByb2Nlc3NlZFRlbXBsYXRlID8gJ1Byb2Nlc3NlZCcgOiAnT3JpZ2luYWwnLFxuICAgICAgfSkucHJvbWlzZSgpO1xuICAgICAgdGhpcy5fdGVtcGxhdGUgPSAocmVzcG9uc2UuVGVtcGxhdGVCb2R5ICYmIGRlc2VyaWFsaXplU3RydWN0dXJlKHJlc3BvbnNlLlRlbXBsYXRlQm9keSkpIHx8IHt9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGU7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGUgc3RhY2sgZXhpc3RzXG4gICAqL1xuICBwdWJsaWMgZ2V0IGV4aXN0cygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFjayAhPT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzdGFjaydzIElEXG4gICAqXG4gICAqIFRocm93cyBpZiB0aGUgc3RhY2sgZG9lc24ndCBleGlzdC5cbiAgICovXG4gIHB1YmxpYyBnZXQgc3RhY2tJZCgpIHtcbiAgICB0aGlzLmFzc2VydEV4aXN0cygpO1xuICAgIHJldHVybiB0aGlzLnN0YWNrIS5TdGFja0lkITtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgc3RhY2sncyBjdXJyZW50IG91dHB1dHNcbiAgICpcbiAgICogRW1wdHkgb2JqZWN0IGlmIHRoZSBzdGFjayBkb2Vzbid0IGV4aXN0XG4gICAqL1xuICBwdWJsaWMgZ2V0IG91dHB1dHMoKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG4gICAgaWYgKCF0aGlzLmV4aXN0cykgeyByZXR1cm4ge307IH1cbiAgICBjb25zdCByZXN1bHQ6IHsgW25hbWU6IHN0cmluZ106IHN0cmluZyB9ID0ge307XG4gICAgKHRoaXMuc3RhY2shLk91dHB1dHMgfHwgW10pLmZvckVhY2gob3V0cHV0ID0+IHtcbiAgICAgIHJlc3VsdFtvdXRwdXQuT3V0cHV0S2V5IV0gPSBvdXRwdXQuT3V0cHV0VmFsdWUhO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHN0YWNrJ3Mgc3RhdHVzXG4gICAqXG4gICAqIFNwZWNpYWwgc3RhdHVzIE5PVF9GT1VORCBpZiB0aGUgc3RhY2sgZG9lcyBub3QgZXhpc3QuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHN0YWNrU3RhdHVzKCk6IFN0YWNrU3RhdHVzIHtcbiAgICBpZiAoIXRoaXMuZXhpc3RzKSB7XG4gICAgICByZXR1cm4gbmV3IFN0YWNrU3RhdHVzKCdOT1RfRk9VTkQnLCAnU3RhY2sgbm90IGZvdW5kIGR1cmluZyBsb29rdXAnKTtcbiAgICB9XG4gICAgcmV0dXJuIFN0YWNrU3RhdHVzLmZyb21TdGFja0Rlc2NyaXB0aW9uKHRoaXMuc3RhY2shKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgc3RhY2sncyBjdXJyZW50IHRhZ3NcbiAgICpcbiAgICogRW1wdHkgbGlzdCBvZiB0aGUgc3RhY2sgZG9lcyBub3QgZXhpc3RcbiAgICovXG4gIHB1YmxpYyBnZXQgdGFncygpOiBDbG91ZEZvcm1hdGlvbi5UYWdzIHtcbiAgICByZXR1cm4gdGhpcy5zdGFjaz8uVGFncyB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG5hbWVzIG9mIGFsbCBjdXJyZW50IHBhcmFtZXRlcnMgdG8gdGhlIHN0YWNrXG4gICAqXG4gICAqIEVtcHR5IGxpc3QgaWYgdGhlIHN0YWNrIGRvZXMgbm90IGV4aXN0LlxuICAgKi9cbiAgcHVibGljIGdldCBwYXJhbWV0ZXJOYW1lcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMucGFyYW1ldGVycyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBuYW1lcyBhbmQgdmFsdWVzIG9mIGFsbCBjdXJyZW50IHBhcmFtZXRlcnMgdG8gdGhlIHN0YWNrXG4gICAqXG4gICAqIEVtcHR5IG9iamVjdCBpZiB0aGUgc3RhY2sgZG9lcyBub3QgZXhpc3QuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHBhcmFtZXRlcnMoKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG4gICAgaWYgKCF0aGlzLmV4aXN0cykgeyByZXR1cm4ge307IH1cbiAgICBjb25zdCByZXQ6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcbiAgICBmb3IgKGNvbnN0IHBhcmFtIG9mIHRoaXMuc3RhY2shLlBhcmFtZXRlcnMgPz8gW10pIHtcbiAgICAgIHJldFtwYXJhbS5QYXJhbWV0ZXJLZXkhXSA9IHBhcmFtLlJlc29sdmVkVmFsdWUgPz8gcGFyYW0uUGFyYW1ldGVyVmFsdWUhO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgdGVybWluYXRpb24gcHJvdGVjdGlvbiBvZiB0aGUgc3RhY2tcbiAgICovXG4gIHB1YmxpYyBnZXQgdGVybWluYXRpb25Qcm90ZWN0aW9uKCk6IGJvb2xlYW4gfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnN0YWNrPy5FbmFibGVUZXJtaW5hdGlvblByb3RlY3Rpb247XG4gIH1cblxuICBwcml2YXRlIGFzc2VydEV4aXN0cygpIHtcbiAgICBpZiAoIXRoaXMuZXhpc3RzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHN0YWNrIG5hbWVkICcke3RoaXMuc3RhY2tOYW1lfSdgKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEZXNjcmliZSBhIGNoYW5nZXNldCBpbiBDbG91ZEZvcm1hdGlvbiwgcmVnYXJkbGVzcyBvZiBpdHMgY3VycmVudCBzdGF0ZS5cbiAqXG4gKiBAcGFyYW0gY2ZuICAgICAgICAgICBhIENsb3VkRm9ybWF0aW9uIGNsaWVudFxuICogQHBhcmFtIHN0YWNrTmFtZSAgICAgdGhlIG5hbWUgb2YgdGhlIFN0YWNrIHRoZSBDaGFuZ2VTZXQgYmVsb25ncyB0b1xuICogQHBhcmFtIGNoYW5nZVNldE5hbWUgdGhlIG5hbWUgb2YgdGhlIENoYW5nZVNldFxuICogQHBhcmFtIGZldGNoQWxsICAgICAgaWYgdHJ1ZSwgZmV0Y2hlcyBhbGwgcGFnZXMgb2YgdGhlIGNoYW5nZSBzZXQgZGVzY3JpcHRpb24uXG4gKlxuICogQHJldHVybnMgICAgICAgQ2xvdWRGb3JtYXRpb24gaW5mb3JtYXRpb24gYWJvdXQgdGhlIENoYW5nZVNldFxuICovXG5hc3luYyBmdW5jdGlvbiBkZXNjcmliZUNoYW5nZVNldChcbiAgY2ZuOiBDbG91ZEZvcm1hdGlvbixcbiAgc3RhY2tOYW1lOiBzdHJpbmcsXG4gIGNoYW5nZVNldE5hbWU6IHN0cmluZyxcbiAgeyBmZXRjaEFsbCB9OiB7IGZldGNoQWxsOiBib29sZWFuIH0sXG4pOiBQcm9taXNlPENsb3VkRm9ybWF0aW9uLkRlc2NyaWJlQ2hhbmdlU2V0T3V0cHV0PiB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2ZuLmRlc2NyaWJlQ2hhbmdlU2V0KHsgU3RhY2tOYW1lOiBzdGFja05hbWUsIENoYW5nZVNldE5hbWU6IGNoYW5nZVNldE5hbWUgfSkucHJvbWlzZSgpO1xuXG4gIC8vIElmIGZldGNoQWxsIGlzIHRydWUsIHRyYXZlcnNlIGFsbCBwYWdlcyBmcm9tIHRoZSBjaGFuZ2Ugc2V0IGRlc2NyaXB0aW9uLlxuICB3aGlsZSAoZmV0Y2hBbGwgJiYgcmVzcG9uc2UuTmV4dFRva2VuICE9IG51bGwpIHtcbiAgICBjb25zdCBuZXh0UGFnZSA9IGF3YWl0IGNmbi5kZXNjcmliZUNoYW5nZVNldCh7XG4gICAgICBTdGFja05hbWU6IHN0YWNrTmFtZSxcbiAgICAgIENoYW5nZVNldE5hbWU6IHJlc3BvbnNlLkNoYW5nZVNldElkID8/IGNoYW5nZVNldE5hbWUsXG4gICAgICBOZXh0VG9rZW46IHJlc3BvbnNlLk5leHRUb2tlbixcbiAgICB9KS5wcm9taXNlKCk7XG5cbiAgICAvLyBDb25zb2xpZGF0ZSB0aGUgY2hhbmdlc1xuICAgIGlmIChuZXh0UGFnZS5DaGFuZ2VzICE9IG51bGwpIHtcbiAgICAgIHJlc3BvbnNlLkNoYW5nZXMgPSByZXNwb25zZS5DaGFuZ2VzICE9IG51bGxcbiAgICAgICAgPyByZXNwb25zZS5DaGFuZ2VzLmNvbmNhdChuZXh0UGFnZS5DaGFuZ2VzKVxuICAgICAgICA6IG5leHRQYWdlLkNoYW5nZXM7XG4gICAgfVxuXG4gICAgLy8gRm9yd2FyZCB0aGUgbmV3IE5leHRUb2tlblxuICAgIHJlc3BvbnNlLk5leHRUb2tlbiA9IG5leHRQYWdlLk5leHRUb2tlbjtcbiAgfVxuXG4gIHJldHVybiByZXNwb25zZTtcbn1cblxuLyoqXG4gKiBXYWl0cyBmb3IgYSBmdW5jdGlvbiB0byByZXR1cm4gbm9uLSt1bmRlZmluZWQrIGJlZm9yZSByZXR1cm5pbmcuXG4gKlxuICogQHBhcmFtIHZhbHVlUHJvdmlkZXIgYSBmdW5jdGlvbiB0aGF0IHdpbGwgcmV0dXJuIGEgdmFsdWUgdGhhdCBpcyBub3QgK3VuZGVmaW5lZCsgb25jZSB0aGUgd2FpdCBzaG91bGQgYmUgb3ZlclxuICogQHBhcmFtIHRpbWVvdXQgICAgIHRoZSB0aW1lIHRvIHdhaXQgYmV0d2VlbiB0d28gY2FsbHMgdG8gK3ZhbHVlUHJvdmlkZXIrXG4gKlxuICogQHJldHVybnMgICAgICAgdGhlIHZhbHVlIHRoYXQgd2FzIHJldHVybmVkIGJ5ICt2YWx1ZVByb3ZpZGVyK1xuICovXG5hc3luYyBmdW5jdGlvbiB3YWl0Rm9yPFQ+KHZhbHVlUHJvdmlkZXI6ICgpID0+IFByb21pc2U8VCB8IG51bGwgfCB1bmRlZmluZWQ+LCB0aW1lb3V0OiBudW1iZXIgPSA1MDAwKTogUHJvbWlzZTxUIHwgdW5kZWZpbmVkPiB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsdWVQcm92aWRlcigpO1xuICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXdhaXQgbmV3IFByb21pc2UoY2IgPT4gc2V0VGltZW91dChjYiwgdGltZW91dCkpO1xuICB9XG59XG5cbi8qKlxuICogV2FpdHMgZm9yIGEgQ2hhbmdlU2V0IHRvIGJlIGF2YWlsYWJsZSBmb3IgdHJpZ2dlcmluZyBhIFN0YWNrVXBkYXRlLlxuICpcbiAqIFdpbGwgcmV0dXJuIGEgY2hhbmdlc2V0IHRoYXQgaXMgZWl0aGVyIHJlYWR5IHRvIGJlIGV4ZWN1dGVkIG9yIGhhcyBubyBjaGFuZ2VzLlxuICogV2lsbCB0aHJvdyBpbiBvdGhlciBjYXNlcy5cbiAqXG4gKiBAcGFyYW0gY2ZuICAgICAgICAgICBhIENsb3VkRm9ybWF0aW9uIGNsaWVudFxuICogQHBhcmFtIHN0YWNrTmFtZSAgICAgdGhlIG5hbWUgb2YgdGhlIFN0YWNrIHRoYXQgdGhlIENoYW5nZVNldCBiZWxvbmdzIHRvXG4gKiBAcGFyYW0gY2hhbmdlU2V0TmFtZSB0aGUgbmFtZSBvZiB0aGUgQ2hhbmdlU2V0XG4gKiBAcGFyYW0gZmV0Y2hBbGwgICAgICBpZiB0cnVlLCBmZXRjaGVzIGFsbCBwYWdlcyBvZiB0aGUgQ2hhbmdlU2V0IGJlZm9yZSByZXR1cm5pbmcuXG4gKlxuICogQHJldHVybnMgICAgICAgdGhlIENsb3VkRm9ybWF0aW9uIGRlc2NyaXB0aW9uIG9mIHRoZSBDaGFuZ2VTZXRcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3YWl0Rm9yQ2hhbmdlU2V0KFxuICBjZm46IENsb3VkRm9ybWF0aW9uLFxuICBzdGFja05hbWU6IHN0cmluZyxcbiAgY2hhbmdlU2V0TmFtZTogc3RyaW5nLFxuICB7IGZldGNoQWxsIH06IHsgZmV0Y2hBbGw6IGJvb2xlYW4gfSxcbik6IFByb21pc2U8Q2xvdWRGb3JtYXRpb24uRGVzY3JpYmVDaGFuZ2VTZXRPdXRwdXQ+IHtcbiAgZGVidWcoJ1dhaXRpbmcgZm9yIGNoYW5nZXNldCAlcyBvbiBzdGFjayAlcyB0byBmaW5pc2ggY3JlYXRpbmcuLi4nLCBjaGFuZ2VTZXROYW1lLCBzdGFja05hbWUpO1xuICBjb25zdCByZXQgPSBhd2FpdCB3YWl0Rm9yKGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IGF3YWl0IGRlc2NyaWJlQ2hhbmdlU2V0KGNmbiwgc3RhY2tOYW1lLCBjaGFuZ2VTZXROYW1lLCB7IGZldGNoQWxsIH0pO1xuICAgIC8vIFRoZSBmb2xsb3dpbmcgZG9lc24ndCB1c2UgYSBzd2l0Y2ggYmVjYXVzZSB0c2Mgd2lsbCBub3QgYWxsb3cgZmFsbC10aHJvdWdoLCBVTkxFU1MgaXQgaXMgYWxsb3dzXG4gICAgLy8gRVZFUllXSEVSRSB0aGF0IHVzZXMgdGhpcyBsaWJyYXJ5IGRpcmVjdGx5IG9yIGluZGlyZWN0bHksIHdoaWNoIGlzIHVuZGVzaXJhYmxlLlxuICAgIGlmIChkZXNjcmlwdGlvbi5TdGF0dXMgPT09ICdDUkVBVEVfUEVORElORycgfHwgZGVzY3JpcHRpb24uU3RhdHVzID09PSAnQ1JFQVRFX0lOX1BST0dSRVNTJykge1xuICAgICAgZGVidWcoJ0NoYW5nZXNldCAlcyBvbiBzdGFjayAlcyBpcyBzdGlsbCBjcmVhdGluZycsIGNoYW5nZVNldE5hbWUsIHN0YWNrTmFtZSk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChkZXNjcmlwdGlvbi5TdGF0dXMgPT09ICdDUkVBVEVfQ09NUExFVEUnIHx8IGNoYW5nZVNldEhhc05vQ2hhbmdlcyhkZXNjcmlwdGlvbikpIHtcbiAgICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBDaGFuZ2VTZXQgJHtjaGFuZ2VTZXROYW1lfSBvbiAke3N0YWNrTmFtZX06ICR7ZGVzY3JpcHRpb24uU3RhdHVzIHx8ICdOT19TVEFUVVMnfSwgJHtkZXNjcmlwdGlvbi5TdGF0dXNSZWFzb24gfHwgJ25vIHJlYXNvbiBwcm92aWRlZCd9YCk7XG4gIH0pO1xuXG4gIGlmICghcmV0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDaGFuZ2Ugc2V0IHRvb2sgdG9vIGxvbmcgdG8gYmUgY3JlYXRlZDsgYWJvcnRpbmcnKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmV4cG9ydCB0eXBlIFByZXBhcmVDaGFuZ2VTZXRPcHRpb25zID0ge1xuICBzdGFjazogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0O1xuICBkZXBsb3ltZW50czogRGVwbG95bWVudHM7XG4gIHV1aWQ6IHN0cmluZztcbiAgd2lsbEV4ZWN1dGU6IGJvb2xlYW47XG4gIHNka1Byb3ZpZGVyOiBTZGtQcm92aWRlcjtcbiAgc3RyZWFtOiBOb2RlSlMuV3JpdGFibGVTdHJlYW07XG4gIHBhcmFtZXRlcnM6IHsgW25hbWU6IHN0cmluZ106IHN0cmluZyB8IHVuZGVmaW5lZCB9O1xuICByZXNvdXJjZXNUb0ltcG9ydD86IFJlc291cmNlc1RvSW1wb3J0O1xufVxuXG5leHBvcnQgdHlwZSBDcmVhdGVDaGFuZ2VTZXRPcHRpb25zID0ge1xuICBjZm46IENsb3VkRm9ybWF0aW9uO1xuICBjaGFuZ2VTZXROYW1lOiBzdHJpbmc7XG4gIHdpbGxFeGVjdXRlOiBib29sZWFuO1xuICBleGlzdHM6IGJvb2xlYW47XG4gIHV1aWQ6IHN0cmluZztcbiAgc3RhY2s6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdDtcbiAgYm9keVBhcmFtZXRlcjogVGVtcGxhdGVCb2R5UGFyYW1ldGVyO1xuICBwYXJhbWV0ZXJzOiB7IFtuYW1lOiBzdHJpbmddOiBzdHJpbmcgfCB1bmRlZmluZWQgfTtcbiAgcmVzb3VyY2VzVG9JbXBvcnQ/OiBSZXNvdXJjZXNUb0ltcG9ydDtcbiAgcm9sZT86IHN0cmluZztcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjaGFuZ2VzZXQgZm9yIGEgZGlmZiBvcGVyYXRpb25cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZURpZmZDaGFuZ2VTZXQob3B0aW9uczogUHJlcGFyZUNoYW5nZVNldE9wdGlvbnMpOiBQcm9taXNlPERlc2NyaWJlQ2hhbmdlU2V0T3V0cHV0IHwgdW5kZWZpbmVkPiB7XG4gIC8vIGBvcHRpb25zLnN0YWNrYCBoYXMgYmVlbiBtb2RpZmllZCB0byBpbmNsdWRlIGFueSBuZXN0ZWQgc3RhY2sgdGVtcGxhdGVzIGRpcmVjdGx5IGlubGluZSB3aXRoIGl0cyBvd24gdGVtcGxhdGUsIHVuZGVyIGEgc3BlY2lhbCBgTmVzdGVkVGVtcGxhdGVgIHByb3BlcnR5LlxuICAvLyBUaHVzIHRoZSBwYXJlbnQgdGVtcGxhdGUncyBSZXNvdXJjZXMgc2VjdGlvbiBjb250YWlucyB0aGUgbmVzdGVkIHRlbXBsYXRlJ3MgQ0RLIG1ldGFkYXRhIGNoZWNrLCB3aGljaCB1c2VzIEZuOjpFcXVhbHMuXG4gIC8vIFRoaXMgY2F1c2VzIENyZWF0ZUNoYW5nZVNldCB0byBmYWlsIHdpdGggYFRlbXBsYXRlIEVycm9yOiBGbjo6RXF1YWxzIGNhbm5vdCBiZSBwYXJ0aWFsbHkgY29sbGFwc2VkYC5cbiAgZm9yIChjb25zdCByZXNvdXJjZSBvZiBPYmplY3QudmFsdWVzKChvcHRpb25zLnN0YWNrLnRlbXBsYXRlLlJlc291cmNlcyA/PyB7fSkpKSB7XG4gICAgaWYgKChyZXNvdXJjZSBhcyBhbnkpLlR5cGUgPT09ICdBV1M6OkNsb3VkRm9ybWF0aW9uOjpTdGFjaycpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBkZWJ1ZygnVGhpcyBzdGFjayBjb250YWlucyBvbmUgb3IgbW9yZSBuZXN0ZWQgc3RhY2tzLCBmYWxsaW5nIGJhY2sgdG8gdGVtcGxhdGUtb25seSBkaWZmLi4uJyk7XG5cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVwbG9hZEJvZHlQYXJhbWV0ZXJBbmRDcmVhdGVDaGFuZ2VTZXQob3B0aW9ucyk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHVwbG9hZEJvZHlQYXJhbWV0ZXJBbmRDcmVhdGVDaGFuZ2VTZXQob3B0aW9uczogUHJlcGFyZUNoYW5nZVNldE9wdGlvbnMpOiBQcm9taXNlPERlc2NyaWJlQ2hhbmdlU2V0T3V0cHV0IHwgdW5kZWZpbmVkPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcHJlcGFyZWRTZGsgPSAoYXdhaXQgb3B0aW9ucy5kZXBsb3ltZW50cy5wcmVwYXJlU2RrV2l0aERlcGxveVJvbGUob3B0aW9ucy5zdGFjaykpO1xuICAgIGNvbnN0IGJvZHlQYXJhbWV0ZXIgPSBhd2FpdCBtYWtlQm9keVBhcmFtZXRlckFuZFVwbG9hZChcbiAgICAgIG9wdGlvbnMuc3RhY2ssXG4gICAgICBwcmVwYXJlZFNkay5yZXNvbHZlZEVudmlyb25tZW50LFxuICAgICAgcHJlcGFyZWRTZGsuZW52UmVzb3VyY2VzLFxuICAgICAgb3B0aW9ucy5zZGtQcm92aWRlcixcbiAgICAgIHByZXBhcmVkU2RrLnN0YWNrU2RrLFxuICAgICk7XG4gICAgY29uc3QgY2ZuID0gcHJlcGFyZWRTZGsuc3RhY2tTZGsuY2xvdWRGb3JtYXRpb24oKTtcbiAgICBjb25zdCBleGlzdHMgPSAoYXdhaXQgQ2xvdWRGb3JtYXRpb25TdGFjay5sb29rdXAoY2ZuLCBvcHRpb25zLnN0YWNrLnN0YWNrTmFtZSwgZmFsc2UpKS5leGlzdHM7XG5cbiAgICBjb25zdCBleGVjdXRpb25Sb2xlQXJuID0gcHJlcGFyZWRTZGsuY2xvdWRGb3JtYXRpb25Sb2xlQXJuO1xuICAgIG9wdGlvbnMuc3RyZWFtLndyaXRlKCdIb2xkIG9uIHdoaWxlIHdlIGNyZWF0ZSBhIHJlYWQtb25seSBjaGFuZ2Ugc2V0IHRvIGdldCBhIGRpZmYgd2l0aCBhY2N1cmF0ZSByZXBsYWNlbWVudCBpbmZvcm1hdGlvbiAodXNlIC0tbm8tY2hhbmdlLXNldCB0byB1c2UgYSBsZXNzIGFjY3VyYXRlIGJ1dCBmYXN0ZXIgdGVtcGxhdGUtb25seSBkaWZmKVxcbicpO1xuXG4gICAgcmV0dXJuIGF3YWl0IGNyZWF0ZUNoYW5nZVNldCh7XG4gICAgICBjZm4sXG4gICAgICBjaGFuZ2VTZXROYW1lOiAnY2RrLWRpZmYtY2hhbmdlLXNldCcsXG4gICAgICBzdGFjazogb3B0aW9ucy5zdGFjayxcbiAgICAgIGV4aXN0cyxcbiAgICAgIHV1aWQ6IG9wdGlvbnMudXVpZCxcbiAgICAgIHdpbGxFeGVjdXRlOiBvcHRpb25zLndpbGxFeGVjdXRlLFxuICAgICAgYm9keVBhcmFtZXRlcixcbiAgICAgIHBhcmFtZXRlcnM6IG9wdGlvbnMucGFyYW1ldGVycyxcbiAgICAgIHJlc291cmNlc1RvSW1wb3J0OiBvcHRpb25zLnJlc291cmNlc1RvSW1wb3J0LFxuICAgICAgcm9sZTogZXhlY3V0aW9uUm9sZUFybixcbiAgICB9KTtcbiAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgZGVidWcoZS5tZXNzYWdlKTtcbiAgICBvcHRpb25zLnN0cmVhbS53cml0ZSgnQ291bGQgbm90IGNyZWF0ZSBhIGNoYW5nZSBzZXQsIHdpbGwgYmFzZSB0aGUgZGlmZiBvbiB0ZW1wbGF0ZSBkaWZmZXJlbmNlcyAocnVuIGFnYWluIHdpdGggLXYgdG8gc2VlIHRoZSByZWFzb24pXFxuJyk7XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUNoYW5nZVNldChvcHRpb25zOiBDcmVhdGVDaGFuZ2VTZXRPcHRpb25zKTogUHJvbWlzZTxEZXNjcmliZUNoYW5nZVNldE91dHB1dD4ge1xuICBhd2FpdCBjbGVhbnVwT2xkQ2hhbmdlc2V0KG9wdGlvbnMuY2hhbmdlU2V0TmFtZSwgb3B0aW9ucy5zdGFjay5zdGFja05hbWUsIG9wdGlvbnMuY2ZuKTtcblxuICBkZWJ1ZyhgQXR0ZW1wdGluZyB0byBjcmVhdGUgQ2hhbmdlU2V0IHdpdGggbmFtZSAke29wdGlvbnMuY2hhbmdlU2V0TmFtZX0gZm9yIHN0YWNrICR7b3B0aW9ucy5zdGFjay5zdGFja05hbWV9YCk7XG5cbiAgY29uc3QgdGVtcGxhdGVQYXJhbXMgPSBUZW1wbGF0ZVBhcmFtZXRlcnMuZnJvbVRlbXBsYXRlKG9wdGlvbnMuc3RhY2sudGVtcGxhdGUpO1xuICBjb25zdCBzdGFja1BhcmFtcyA9IHRlbXBsYXRlUGFyYW1zLnN1cHBseUFsbChvcHRpb25zLnBhcmFtZXRlcnMpO1xuXG4gIGNvbnN0IGNoYW5nZVNldCA9IGF3YWl0IG9wdGlvbnMuY2ZuLmNyZWF0ZUNoYW5nZVNldCh7XG4gICAgU3RhY2tOYW1lOiBvcHRpb25zLnN0YWNrLnN0YWNrTmFtZSxcbiAgICBDaGFuZ2VTZXROYW1lOiBvcHRpb25zLmNoYW5nZVNldE5hbWUsXG4gICAgQ2hhbmdlU2V0VHlwZTogb3B0aW9ucy5yZXNvdXJjZXNUb0ltcG9ydCA/ICdJTVBPUlQnIDogb3B0aW9ucy5leGlzdHMgPyAnVVBEQVRFJyA6ICdDUkVBVEUnLFxuICAgIERlc2NyaXB0aW9uOiBgQ0RLIENoYW5nZXNldCBmb3IgZGlmZiAke29wdGlvbnMudXVpZH1gLFxuICAgIENsaWVudFRva2VuOiBgZGlmZiR7b3B0aW9ucy51dWlkfWAsXG4gICAgVGVtcGxhdGVVUkw6IG9wdGlvbnMuYm9keVBhcmFtZXRlci5UZW1wbGF0ZVVSTCxcbiAgICBUZW1wbGF0ZUJvZHk6IG9wdGlvbnMuYm9keVBhcmFtZXRlci5UZW1wbGF0ZUJvZHksXG4gICAgUGFyYW1ldGVyczogc3RhY2tQYXJhbXMuYXBpUGFyYW1ldGVycyxcbiAgICBSZXNvdXJjZXNUb0ltcG9ydDogb3B0aW9ucy5yZXNvdXJjZXNUb0ltcG9ydCxcbiAgICBSb2xlQVJOOiBvcHRpb25zLnJvbGUsXG4gICAgQ2FwYWJpbGl0aWVzOiBbJ0NBUEFCSUxJVFlfSUFNJywgJ0NBUEFCSUxJVFlfTkFNRURfSUFNJywgJ0NBUEFCSUxJVFlfQVVUT19FWFBBTkQnXSxcbiAgfSkucHJvbWlzZSgpO1xuXG4gIGRlYnVnKCdJbml0aWF0ZWQgY3JlYXRpb24gb2YgY2hhbmdlc2V0OiAlczsgd2FpdGluZyBmb3IgaXQgdG8gZmluaXNoIGNyZWF0aW5nLi4uJywgY2hhbmdlU2V0LklkKTtcbiAgLy8gRmV0Y2hpbmcgYWxsIHBhZ2VzIGlmIHdlJ2xsIGV4ZWN1dGUsIHNvIHdlIGNhbiBoYXZlIHRoZSBjb3JyZWN0IGNoYW5nZSBjb3VudCB3aGVuIG1vbml0b3JpbmcuXG4gIGNvbnN0IGNyZWF0ZWRDaGFuZ2VTZXQgPSBhd2FpdCB3YWl0Rm9yQ2hhbmdlU2V0KG9wdGlvbnMuY2ZuLCBvcHRpb25zLnN0YWNrLnN0YWNrTmFtZSwgb3B0aW9ucy5jaGFuZ2VTZXROYW1lLCB7IGZldGNoQWxsOiBvcHRpb25zLndpbGxFeGVjdXRlIH0pO1xuICBhd2FpdCBjbGVhbnVwT2xkQ2hhbmdlc2V0KG9wdGlvbnMuY2hhbmdlU2V0TmFtZSwgb3B0aW9ucy5zdGFjay5zdGFja05hbWUsIG9wdGlvbnMuY2ZuKTtcblxuICAvLyBUT0RPOiBVcGRhdGUgdGhpcyBvbmNlIHdlIHJlbW92ZSBzZGt2MiBmcm9tIHRoZSByZXN0IG9mIHRoaXMgcGFja2FnZVxuICByZXR1cm4gY3JlYXRlZENoYW5nZVNldCBhcyBEZXNjcmliZUNoYW5nZVNldE91dHB1dDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNsZWFudXBPbGRDaGFuZ2VzZXQoY2hhbmdlU2V0TmFtZTogc3RyaW5nLCBzdGFja05hbWU6IHN0cmluZywgY2ZuOiBDbG91ZEZvcm1hdGlvbikge1xuICAvLyBEZWxldGUgYW55IGV4aXN0aW5nIGNoYW5nZSBzZXRzIGdlbmVyYXRlZCBieSBDREsgc2luY2UgY2hhbmdlIHNldCBuYW1lcyBtdXN0IGJlIHVuaXF1ZS5cbiAgLy8gVGhlIGRlbGV0ZSByZXF1ZXN0IGlzIHN1Y2Nlc3NmdWwgYXMgbG9uZyBhcyB0aGUgc3RhY2sgZXhpc3RzIChldmVuIGlmIHRoZSBjaGFuZ2Ugc2V0IGRvZXMgbm90IGV4aXN0KS5cbiAgZGVidWcoYFJlbW92aW5nIGV4aXN0aW5nIGNoYW5nZSBzZXQgd2l0aCBuYW1lICR7Y2hhbmdlU2V0TmFtZX0gaWYgaXQgZXhpc3RzYCk7XG4gIGF3YWl0IGNmbi5kZWxldGVDaGFuZ2VTZXQoeyBTdGFja05hbWU6IHN0YWNrTmFtZSwgQ2hhbmdlU2V0TmFtZTogY2hhbmdlU2V0TmFtZSB9KS5wcm9taXNlKCk7XG59XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgdGhlIGdpdmVuIGNoYW5nZSBzZXQgaGFzIG5vIGNoYW5nZXNcbiAqXG4gKiBUaGlzIG11c3QgYmUgZGV0ZXJtaW5lZCBmcm9tIHRoZSBzdGF0dXMsIG5vdCB0aGUgJ0NoYW5nZXMnIGFycmF5IG9uIHRoZVxuICogb2JqZWN0OyB0aGUgbGF0dGVyIGNhbiBiZSBlbXB0eSBiZWNhdXNlIG5vIHJlc291cmNlcyB3ZXJlIGNoYW5nZWQsIGJ1dCBpZlxuICogdGhlcmUgYXJlIGNoYW5nZXMgdG8gT3V0cHV0cywgdGhlIGNoYW5nZSBzZXQgY2FuIHN0aWxsIGJlIGV4ZWN1dGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hhbmdlU2V0SGFzTm9DaGFuZ2VzKGRlc2NyaXB0aW9uOiBDbG91ZEZvcm1hdGlvbi5EZXNjcmliZUNoYW5nZVNldE91dHB1dCkge1xuICBjb25zdCBub0NoYW5nZUVycm9yUHJlZml4ZXMgPSBbXG4gICAgLy8gRXJyb3IgbWVzc2FnZSBmb3IgYSByZWd1bGFyIHRlbXBsYXRlXG4gICAgJ1RoZSBzdWJtaXR0ZWQgaW5mb3JtYXRpb24gZGlkblxcJ3QgY29udGFpbiBjaGFuZ2VzLicsXG4gICAgLy8gRXJyb3IgbWVzc2FnZSB3aGVuIGEgVHJhbnNmb3JtIGlzIGludm9sdmVkIChzZWUgIzEwNjUwKVxuICAgICdObyB1cGRhdGVzIGFyZSB0byBiZSBwZXJmb3JtZWQuJyxcbiAgXTtcblxuICByZXR1cm4gZGVzY3JpcHRpb24uU3RhdHVzID09PSAnRkFJTEVEJ1xuICAgICYmIG5vQ2hhbmdlRXJyb3JQcmVmaXhlcy5zb21lKHAgPT4gKGRlc2NyaXB0aW9uLlN0YXR1c1JlYXNvbiA/PyAnJykuc3RhcnRzV2l0aChwKSk7XG59XG5cbi8qKlxuICogV2FpdHMgZm9yIGEgQ2xvdWRGb3JtYXRpb24gc3RhY2sgdG8gc3RhYmlsaXplIGluIGEgY29tcGxldGUvYXZhaWxhYmxlIHN0YXRlXG4gKiBhZnRlciBhIGRlbGV0ZSBvcGVyYXRpb24gaXMgaXNzdWVkLlxuICpcbiAqIEZhaWxzIGlmIHRoZSBzdGFjayBpcyBpbiBhIEZBSUxFRCBzdGF0ZS4gV2lsbCBub3QgZmFpbCBpZiB0aGUgc3RhY2sgd2FzXG4gKiBhbHJlYWR5IGRlbGV0ZWQuXG4gKlxuICogQHBhcmFtIGNmbiAgICAgICAgYSBDbG91ZEZvcm1hdGlvbiBjbGllbnRcbiAqIEBwYXJhbSBzdGFja05hbWUgICAgICB0aGUgbmFtZSBvZiB0aGUgc3RhY2sgdG8gd2FpdCBmb3IgYWZ0ZXIgYSBkZWxldGVcbiAqXG4gKiBAcmV0dXJucyAgICAgdGhlIENsb3VkRm9ybWF0aW9uIGRlc2NyaXB0aW9uIG9mIHRoZSBzdGFiaWxpemVkIHN0YWNrIGFmdGVyIHRoZSBkZWxldGUgYXR0ZW1wdFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd2FpdEZvclN0YWNrRGVsZXRlKFxuICBjZm46IENsb3VkRm9ybWF0aW9uLFxuICBzdGFja05hbWU6IHN0cmluZyk6IFByb21pc2U8Q2xvdWRGb3JtYXRpb25TdGFjayB8IHVuZGVmaW5lZD4ge1xuXG4gIGNvbnN0IHN0YWNrID0gYXdhaXQgc3RhYmlsaXplU3RhY2soY2ZuLCBzdGFja05hbWUpO1xuICBpZiAoIXN0YWNrKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cblxuICBjb25zdCBzdGF0dXMgPSBzdGFjay5zdGFja1N0YXR1cztcbiAgaWYgKHN0YXR1cy5pc0ZhaWx1cmUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzdGFjayBuYW1lZCAke3N0YWNrTmFtZX0gaXMgaW4gYSBmYWlsZWQgc3RhdGUuIFlvdSBtYXkgbmVlZCB0byBkZWxldGUgaXQgZnJvbSB0aGUgQVdTIGNvbnNvbGUgOiAke3N0YXR1c31gKTtcbiAgfSBlbHNlIGlmIChzdGF0dXMuaXNEZWxldGVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gc3RhY2s7XG59XG5cbi8qKlxuICogV2FpdHMgZm9yIGEgQ2xvdWRGb3JtYXRpb24gc3RhY2sgdG8gc3RhYmlsaXplIGluIGEgY29tcGxldGUvYXZhaWxhYmxlIHN0YXRlXG4gKiBhZnRlciBhbiB1cGRhdGUvY3JlYXRlIG9wZXJhdGlvbiBpcyBpc3N1ZWQuXG4gKlxuICogRmFpbHMgaWYgdGhlIHN0YWNrIGlzIGluIGEgRkFJTEVEIHN0YXRlLCBST0xMQkFDSyBzdGF0ZSwgb3IgREVMRVRFRCBzdGF0ZS5cbiAqXG4gKiBAcGFyYW0gY2ZuICAgICAgICBhIENsb3VkRm9ybWF0aW9uIGNsaWVudFxuICogQHBhcmFtIHN0YWNrTmFtZSAgICAgIHRoZSBuYW1lIG9mIHRoZSBzdGFjayB0byB3YWl0IGZvciBhZnRlciBhbiB1cGRhdGVcbiAqXG4gKiBAcmV0dXJucyAgICAgdGhlIENsb3VkRm9ybWF0aW9uIGRlc2NyaXB0aW9uIG9mIHRoZSBzdGFiaWxpemVkIHN0YWNrIGFmdGVyIHRoZSB1cGRhdGUgYXR0ZW1wdFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd2FpdEZvclN0YWNrRGVwbG95KFxuICBjZm46IENsb3VkRm9ybWF0aW9uLFxuICBzdGFja05hbWU6IHN0cmluZyk6IFByb21pc2U8Q2xvdWRGb3JtYXRpb25TdGFjayB8IHVuZGVmaW5lZD4ge1xuXG4gIGNvbnN0IHN0YWNrID0gYXdhaXQgc3RhYmlsaXplU3RhY2soY2ZuLCBzdGFja05hbWUpO1xuICBpZiAoIXN0YWNrKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cblxuICBjb25zdCBzdGF0dXMgPSBzdGFjay5zdGFja1N0YXR1cztcblxuICBpZiAoc3RhdHVzLmlzQ3JlYXRpb25GYWlsdXJlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgc3RhY2sgbmFtZWQgJHtzdGFja05hbWV9IGZhaWxlZCBjcmVhdGlvbiwgaXQgbWF5IG5lZWQgdG8gYmUgbWFudWFsbHkgZGVsZXRlZCBmcm9tIHRoZSBBV1MgY29uc29sZTogJHtzdGF0dXN9YCk7XG4gIH0gZWxzZSBpZiAoIXN0YXR1cy5pc0RlcGxveVN1Y2Nlc3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzdGFjayBuYW1lZCAke3N0YWNrTmFtZX0gZmFpbGVkIHRvIGRlcGxveTogJHtzdGF0dXN9YCk7XG4gIH1cblxuICByZXR1cm4gc3RhY2s7XG59XG5cbi8qKlxuICogV2FpdCBmb3IgYSBzdGFjayB0byBiZWNvbWUgc3RhYmxlIChubyBsb25nZXIgX0lOX1BST0dSRVNTKSwgcmV0dXJuaW5nIGl0XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdGFiaWxpemVTdGFjayhjZm46IENsb3VkRm9ybWF0aW9uLCBzdGFja05hbWU6IHN0cmluZykge1xuICBkZWJ1ZygnV2FpdGluZyBmb3Igc3RhY2sgJXMgdG8gZmluaXNoIGNyZWF0aW5nIG9yIHVwZGF0aW5nLi4uJywgc3RhY2tOYW1lKTtcbiAgcmV0dXJuIHdhaXRGb3IoYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHN0YWNrID0gYXdhaXQgQ2xvdWRGb3JtYXRpb25TdGFjay5sb29rdXAoY2ZuLCBzdGFja05hbWUpO1xuICAgIGlmICghc3RhY2suZXhpc3RzKSB7XG4gICAgICBkZWJ1ZygnU3RhY2sgJXMgZG9lcyBub3QgZXhpc3QnLCBzdGFja05hbWUpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHN0YXR1cyA9IHN0YWNrLnN0YWNrU3RhdHVzO1xuICAgIGlmIChzdGF0dXMuaXNJblByb2dyZXNzKSB7XG4gICAgICBkZWJ1ZygnU3RhY2sgJXMgaGFzIGFuIG9uZ29pbmcgb3BlcmF0aW9uIGluIHByb2dyZXNzIGFuZCBpcyBub3Qgc3RhYmxlICglcyknLCBzdGFja05hbWUsIHN0YXR1cyk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAoc3RhdHVzLmlzUmV2aWV3SW5Qcm9ncmVzcykge1xuICAgICAgLy8gVGhpcyBtYXkgaGFwcGVuIGlmIGEgc3RhY2sgY3JlYXRpb24gb3BlcmF0aW9uIGlzIGludGVycnVwdGVkIGJlZm9yZSB0aGUgQ2hhbmdlU2V0IGV4ZWN1dGlvbiBzdGFydHMuIFJlY292ZXJpbmdcbiAgICAgIC8vIGZyb20gdGhpcyB3b3VsZCByZXF1aXJpbmcgbWFudWFsIGludGVydmVudGlvbiAoZGVsZXRpbmcgb3IgZXhlY3V0aW5nIHRoZSBwZW5kaW5nIENoYW5nZVNldCksIGFuZCBmYWlsaW5nIHRvIGRvXG4gICAgICAvLyBzbyB3aWxsIHJlc3VsdCBpbiBhbiBlbmRsZXNzIHdhaXQgaGVyZSAodGhlIENoYW5nZVNldCB3b250IGRlbGV0ZSBvciBleGVjdXRlIGl0c2VsZikuIEluc3RlYWQgb2YgYmxvY2tpbmdcbiAgICAgIC8vIFwiZm9yZXZlclwiIHdlIHByb2NlZWQgYXMgaWYgdGhlIHN0YWNrIHdhcyBleGlzdGluZyBhbmQgc3RhYmxlLiBJZiB0aGVyZSBpcyBhIGNvbmN1cnJlbnQgb3BlcmF0aW9uIHRoYXQganVzdFxuICAgICAgLy8gaGFzbid0IGZpbmlzaGVkIHByb2NlZWRpbmcganVzdCB5ZXQsIGVpdGhlciB0aGlzIG9wZXJhdGlvbiBvciB0aGUgY29uY3VycmVudCBvbmUgbWF5IGZhaWwgZHVlIHRvIHRoZSBvdGhlciBvbmVcbiAgICAgIC8vIGhhdmluZyBtYWRlIHByb2dyZXNzLiBXaGljaCBpcyBmaW5lLiBJIGd1ZXNzLlxuICAgICAgZGVidWcoJ1N0YWNrICVzIGlzIGluIFJFVklFV19JTl9QUk9HUkVTUyBzdGF0ZS4gQ29uc2lkZXJpbmcgdGhpcyBpcyBhIHN0YWJsZSBzdGF0dXMgKCVzKScsIHN0YWNrTmFtZSwgc3RhdHVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhY2s7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRoZSBzZXQgb2YgKGZvcm1hbCkgcGFyYW1ldGVycyB0aGF0IGhhdmUgYmVlbiBkZWNsYXJlZCBpbiBhIHRlbXBsYXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBUZW1wbGF0ZVBhcmFtZXRlcnMge1xuICBwdWJsaWMgc3RhdGljIGZyb21UZW1wbGF0ZSh0ZW1wbGF0ZTogVGVtcGxhdGUpIHtcbiAgICByZXR1cm4gbmV3IFRlbXBsYXRlUGFyYW1ldGVycyh0ZW1wbGF0ZS5QYXJhbWV0ZXJzIHx8IHt9KTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgcGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBUZW1wbGF0ZVBhcmFtZXRlcj4pIHtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgc3RhY2sgcGFyYW1ldGVycyB0byBwYXNzIGZyb20gdGhlIGdpdmVuIGRlc2lyZWQgcGFyYW1ldGVyIHZhbHVlc1xuICAgKlxuICAgKiBXaWxsIHRocm93IGlmIHBhcmFtZXRlcnMgd2l0aG91dCBhIERlZmF1bHQgdmFsdWUgb3IgYSBQcmV2aW91cyB2YWx1ZSBhcmUgbm90XG4gICAqIHN1cHBsaWVkLlxuICAgKi9cbiAgcHVibGljIHN1cHBseUFsbCh1cGRhdGVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCB1bmRlZmluZWQ+KTogUGFyYW1ldGVyVmFsdWVzIHtcbiAgICByZXR1cm4gbmV3IFBhcmFtZXRlclZhbHVlcyh0aGlzLnBhcmFtcywgdXBkYXRlcyk7XG4gIH1cblxuICAvKipcbiAgICogRnJvbSB0aGUgdGVtcGxhdGUsIHRoZSBnaXZlbiBkZXNpcmVkIHZhbHVlcyBhbmQgdGhlIGN1cnJlbnQgdmFsdWVzLCBjYWxjdWxhdGUgdGhlIGNoYW5nZXMgdG8gdGhlIHN0YWNrIHBhcmFtZXRlcnNcbiAgICpcbiAgICogV2lsbCB0YWtlIGludG8gYWNjb3VudCBwYXJhbWV0ZXJzIGFscmVhZHkgc2V0IG9uIHRoZSB0ZW1wbGF0ZSAod2lsbCBlbWl0XG4gICAqICdVc2VQcmV2aW91c1ZhbHVlOiB0cnVlJyBmb3IgdGhvc2UgdW5sZXNzIHRoZSB2YWx1ZSBpcyBjaGFuZ2VkKSwgYW5kIHdpbGxcbiAgICogdGhyb3cgaWYgcGFyYW1ldGVycyB3aXRob3V0IGEgRGVmYXVsdCB2YWx1ZSBvciBhIFByZXZpb3VzIHZhbHVlIGFyZSBub3RcbiAgICogc3VwcGxpZWQuXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlRXhpc3RpbmcodXBkYXRlczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkPiwgcHJldmlvdXNWYWx1ZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pOiBQYXJhbWV0ZXJWYWx1ZXMge1xuICAgIHJldHVybiBuZXcgUGFyYW1ldGVyVmFsdWVzKHRoaXMucGFyYW1zLCB1cGRhdGVzLCBwcmV2aW91c1ZhbHVlcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgc2V0IG9mIHBhcmFtZXRlcnMgd2UncmUgZ29pbmcgdG8gcGFzcyB0byBhIFN0YWNrXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXJhbWV0ZXJWYWx1ZXMge1xuICBwdWJsaWMgcmVhZG9ubHkgdmFsdWVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gIHB1YmxpYyByZWFkb25seSBhcGlQYXJhbWV0ZXJzOiBDbG91ZEZvcm1hdGlvbi5QYXJhbWV0ZXJbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZm9ybWFsUGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBUZW1wbGF0ZVBhcmFtZXRlcj4sXG4gICAgdXBkYXRlczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkPixcbiAgICBwcmV2aW91c1ZhbHVlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9KSB7XG5cbiAgICBjb25zdCBtaXNzaW5nUmVxdWlyZWQgPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xuXG4gICAgZm9yIChjb25zdCBba2V5LCBmb3JtYWxQYXJhbV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5mb3JtYWxQYXJhbXMpKSB7XG4gICAgICAvLyBDaGVjayB1cGRhdGVzIGZpcnN0LCB0aGVuIHVzZSB0aGUgcHJldmlvdXMgdmFsdWUgKGlmIGF2YWlsYWJsZSksIHRoZW4gdXNlXG4gICAgICAvLyB0aGUgZGVmYXVsdCAoaWYgYXZhaWxhYmxlKS5cbiAgICAgIC8vXG4gICAgICAvLyBJZiB3ZSBkb24ndCBmaW5kIGEgcGFyYW1ldGVyIHZhbHVlIHVzaW5nIGFueSBvZiB0aGVzZSBtZXRob2RzLCB0aGVuIHRoYXQncyBhbiBlcnJvci5cbiAgICAgIGNvbnN0IHVwZGF0ZWRWYWx1ZSA9IHVwZGF0ZXNba2V5XTtcbiAgICAgIGlmICh1cGRhdGVkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnZhbHVlc1trZXldID0gdXBkYXRlZFZhbHVlO1xuICAgICAgICB0aGlzLmFwaVBhcmFtZXRlcnMucHVzaCh7IFBhcmFtZXRlcktleToga2V5LCBQYXJhbWV0ZXJWYWx1ZTogdXBkYXRlc1trZXldIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleSBpbiBwcmV2aW91c1ZhbHVlcykge1xuICAgICAgICB0aGlzLnZhbHVlc1trZXldID0gcHJldmlvdXNWYWx1ZXNba2V5XTtcbiAgICAgICAgdGhpcy5hcGlQYXJhbWV0ZXJzLnB1c2goeyBQYXJhbWV0ZXJLZXk6IGtleSwgVXNlUHJldmlvdXNWYWx1ZTogdHJ1ZSB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3JtYWxQYXJhbS5EZWZhdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy52YWx1ZXNba2V5XSA9IGZvcm1hbFBhcmFtLkRlZmF1bHQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBPaCBub1xuICAgICAgbWlzc2luZ1JlcXVpcmVkLnB1c2goa2V5KTtcbiAgICB9XG5cbiAgICBpZiAobWlzc2luZ1JlcXVpcmVkLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGZvbGxvd2luZyBDbG91ZEZvcm1hdGlvbiBQYXJhbWV0ZXJzIGFyZSBtaXNzaW5nIGEgdmFsdWU6ICR7bWlzc2luZ1JlcXVpcmVkLmpvaW4oJywgJyl9YCk7XG4gICAgfVxuXG4gICAgLy8gSnVzdCBhcHBlbmQgYWxsIHN1cHBsaWVkIG92ZXJyaWRlcyB0aGF0IGFyZW4ndCByZWFsbHkgZXhwZWN0ZWQgKHRoaXNcbiAgICAvLyB3aWxsIGZhaWwgQ0ZOIGJ1dCBtYXliZSBwZW9wbGUgbWFkZSB0eXBvcyB0aGF0IHRoZXkgd2FudCB0byBiZSBub3RpZmllZFxuICAgIC8vIG9mKVxuICAgIGNvbnN0IHVua25vd25QYXJhbSA9IChba2V5LCBfXTogW3N0cmluZywgYW55XSkgPT4gdGhpcy5mb3JtYWxQYXJhbXNba2V5XSA9PT0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGhhc1ZhbHVlID0gKFtfLCB2YWx1ZV06IFtzdHJpbmcsIGFueV0pID0+ICEhdmFsdWU7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModXBkYXRlcykuZmlsdGVyKHVua25vd25QYXJhbSkuZmlsdGVyKGhhc1ZhbHVlKSkge1xuICAgICAgdGhpcy52YWx1ZXNba2V5XSA9IHZhbHVlITtcbiAgICAgIHRoaXMuYXBpUGFyYW1ldGVycy5wdXNoKHsgUGFyYW1ldGVyS2V5OiBrZXksIFBhcmFtZXRlclZhbHVlOiB2YWx1ZSB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGlzIHNldCBvZiBwYXJhbWV0ZXIgdXBkYXRlcyB3aWxsIGNoYW5nZSB0aGUgYWN0dWFsIHN0YWNrIHZhbHVlc1xuICAgKi9cbiAgcHVibGljIGhhc0NoYW5nZXMoY3VycmVudFZhbHVlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPik6IFBhcmFtZXRlckNoYW5nZXMge1xuICAgIC8vIElmIGFueSBvZiB0aGUgcGFyYW1ldGVycyBhcmUgU1NNIHBhcmFtZXRlcnMsIGRlcGxveWluZyBtdXN0IGFsd2F5cyBoYXBwZW5cbiAgICAvLyBiZWNhdXNlIHdlIGNhbid0IHByZWRpY3Qgd2hhdCB0aGUgdmFsdWVzIHdpbGwgYmUuIFdlIHdpbGwgYWxsb3cgc29tZVxuICAgIC8vIHBhcmFtZXRlcnMgdG8gb3B0IG91dCBvZiB0aGlzIGNoZWNrIGJ5IGhhdmluZyBhIG1hZ2ljIHN0cmluZyBpbiB0aGVpciBkZXNjcmlwdGlvbi5cbiAgICBpZiAoT2JqZWN0LnZhbHVlcyh0aGlzLmZvcm1hbFBhcmFtcykuc29tZShwID0+IHAuVHlwZS5zdGFydHNXaXRoKCdBV1M6OlNTTTo6UGFyYW1ldGVyOjonKSAmJiAhcC5EZXNjcmlwdGlvbj8uaW5jbHVkZXMoU1NNUEFSQU1fTk9fSU5WQUxJREFURSkpKSB7XG4gICAgICByZXR1cm4gJ3NzbSc7XG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlIHdlJ3JlIGRpcnR5IGlmOlxuICAgIC8vIC0gYW55IG9mIHRoZSBleGlzdGluZyB2YWx1ZXMgYXJlIHJlbW92ZWQsIG9yIGNoYW5nZWRcbiAgICBpZiAoT2JqZWN0LmVudHJpZXMoY3VycmVudFZhbHVlcykuc29tZSgoW2tleSwgdmFsdWVdKSA9PiAhKGtleSBpbiB0aGlzLnZhbHVlcykgfHwgdmFsdWUgIT09IHRoaXMudmFsdWVzW2tleV0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyAtIGFueSBvZiB0aGUgdmFsdWVzIHdlJ3JlIHNldHRpbmcgYXJlIG5ld1xuICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLnZhbHVlcykuc29tZShrZXkgPT4gIShrZXkgaW4gY3VycmVudFZhbHVlcykpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgUGFyYW1ldGVyQ2hhbmdlcyA9IGJvb2xlYW4gfCAnc3NtJztcbiJdfQ==